import json
from pathlib import Path

# =========================
# Config
# =========================
STRIP_ROOT = Path("strip")
OUTPUT_JS = Path("strip_data.js")
VALID_EXTS = {".png", ".jpg", ".jpeg", ".webp"}

# =========================
# Helpers
# =========================
def is_step_dir(p: Path) -> bool:
    return p.is_dir() and p.name.isdigit()

def read_prompts_or_empty(txt_path: Path, n_imgs: int):
    if not txt_path.exists():
        print(f"[WARN] Missing {txt_path}, using empty prompts.")
        return [""] * n_imgs

    with open(txt_path, "r", encoding="utf-8") as f:
        prompts = [line.strip() for line in f if line.strip()]

    if len(prompts) < n_imgs:
        raise ValueError(
            f"[ERROR] {txt_path}: {len(prompts)} prompts < {n_imgs} images"
        )

    return prompts[:n_imgs]

def collect_images(folder: Path):
    imgs = [
        p for p in folder.iterdir()
        if p.is_file() and p.suffix.lower() in VALID_EXTS
    ]
    return sorted(imgs, key=lambda p: p.name)

# =========================
# Main
# =========================
data = {}

step_dirs = sorted(
    [p for p in STRIP_ROOT.iterdir() if is_step_dir(p)],
    key=lambda p: int(p.name)
)

if not step_dirs:
    raise RuntimeError(f"No numeric step folders under {STRIP_ROOT}")

for step_dir in step_dirs:
    step = int(step_dir.name)
    images = collect_images(step_dir)

    if not images:
        print(f"[WARN] step {step}: no images, skipped")
        continue

    text_file = step_dir / "text.txt"
    prompts = read_prompts_or_empty(text_file, len(images))

    items = []
    for img, prompt in zip(images, prompts):
        items.append({
            "src": f"strip/{step}/{img.name}",
            "prompt": prompt
        })

    data[step] = items
    print(f"[OK] step {step}: {len(items)} items")

# =========================
# Write JS
# =========================
with open(OUTPUT_JS, "w", encoding="utf-8") as f:
    f.write("// Auto-generated by generate_strip_js.py\n")
    f.write("window.SELFE_STRIP_DATA = ")
    json.dump(
        data,
        f,
        indent=2,
        ensure_ascii=False
    )
    f.write(";\n")

print(f"\n[DONE] Generated {OUTPUT_JS.resolve()}")
